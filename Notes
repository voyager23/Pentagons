// index table for base to working
00 01 02 03 04 
00 04 03 02 01 
02 01 00 04 03 
04 03 02 01 00 
01 00 04 03 02 
03 02 01 00 04 

04 00 01 02 03 
04 03 02 01 00 
01 00 04 03 02 
03 02 01 00 04 
00 04 03 02 01 
02 01 00 04 03 

03 04 00 01 02 
03 02 01 00 04 
00 04 03 02 01 
02 01 00 04 03 
04 03 02 01 00 
01 00 04 03 02 

02 03 04 00 01 
02 01 00 04 03 
04 03 02 01 00 
01 00 04 03 02 
03 02 01 00 04 
00 04 03 02 01 

01 02 03 04 00 
01 00 04 03 02 
03 02 01 00 04 
00 04 03 02 01 
02 01 00 04 03 
04 03 02 01 00 

00 01 02 03 04 

//----------------------------------------------------------------------
					for(e=*Nodes; e != NULL; e = e->next) {
						//
						for(t=0; t<NTHREADS; t++) {
							tdb[t].e = g_slist_nth(e,t);
							tdb[t].found=0;
							tdb[t].offset_e=t;
							//pthread_create( &(tdb[t].thread_id), NULL, worker_e, p_tdb);
						}
						
						if((e==d)||(e==c)||(e==b)||(e==a)) continue;
						if(	// testing for link values
							(NPTR(e)->primes[0] != NPTR(d)->primes[1])||
							(NPTR(e)->primes[1] != NPTR(a)->primes[0])||
							(NPTR(e)->primes[2] != NPTR(b)->primes[3])||
							(NPTR(e)->primes[3] != NPTR(c)->primes[2])) continue;
						// a-b-c-d-e is a pentagon
						// found a Pentagon
						struct ring5 *working = malloc(sizeof(struct ring5));					
						working->nodes[0] = NPTR(a);							
						working->nodes[1] = NPTR(b);
						working->nodes[2] = NPTR(c);
						working->nodes[3] = NPTR(d);
						working->nodes[4] = NPTR(e);
						// if this pentagon is already in list - ignore
						if(add_Pentagon_to_list(Pentagons,BasePentas,working) == 1) n_pentagons+=10;							
						free(working);
					} // e loop
//----------------------------------------------------------------------


[mike@europa Pentagon]$ ./penta 
Using default Target 84.
Target:  84  n_primes:  24  n_nodes:  936  n_unique:   12
==========
  p0 =   31  p1 =   41  p2 =    7  p3 =    5
  p0 =   41  p1 =   11  p2 =   19  p3 =   13
  p0 =   11  p1 =   43  p2 =   23  p3 =    7
  p0 =   43  p1 =   17  p2 =    5  p3 =   19
  p0 =   17  p1 =   31  p2 =   13  p3 =   23
==========
  p0 =   31  p1 =   41  p2 =    5  p3 =    7
  p0 =   41  p1 =   19  p2 =   11  p3 =   13
  p0 =   19  p1 =   43  p2 =   17  p3 =    5
  p0 =   43  p1 =   23  p2 =    7  p3 =   11
  p0 =   23  p1 =   31  p2 =   13  p3 =   17
==========
  p0 =    7  p1 =   41  p2 =   31  p3 =    5
  p0 =   41  p1 =   13  p2 =   19  p3 =   11
  p0 =   13  p1 =   17  p2 =   23  p3 =   31
  p0 =   17  p1 =   43  p2 =    5  p3 =   19
  p0 =   43  p1 =    7  p2 =   11  p3 =   23
==========
  p0 =    7  p1 =   41  p2 =    5  p3 =   31
  p0 =   41  p1 =   19  p2 =   13  p3 =   11
  p0 =   19  p1 =   17  p2 =   43  p3 =    5
  p0 =   17  p1 =   23  p2 =   31  p3 =   13
  p0 =   23  p1 =    7  p2 =   11  p3 =   43
==========
  p0 =    7  p1 =   31  p2 =   41  p3 =    5
  p0 =   31  p1 =   13  p2 =   17  p3 =   23
  p0 =   13  p1 =   19  p2 =   11  p3 =   41
  p0 =   19  p1 =   43  p2 =    5  p3 =   17
  p0 =   43  p1 =    7  p2 =   23  p3 =   11
==========
  p0 =    7  p1 =   31  p2 =    5  p3 =   41
  p0 =   31  p1 =   17  p2 =   13  p3 =   23
  p0 =   17  p1 =   19  p2 =   43  p3 =    5
  p0 =   19  p1 =   11  p2 =   41  p3 =   13
  p0 =   11  p1 =    7  p2 =   23  p3 =   43
==========
  p0 =    5  p1 =   41  p2 =   31  p3 =    7
  p0 =   41  p1 =   13  p2 =   11  p3 =   19
  p0 =   13  p1 =   23  p2 =   17  p3 =   31
  p0 =   23  p1 =   43  p2 =    7  p3 =   11
  p0 =   43  p1 =    5  p2 =   19  p3 =   17
==========
  p0 =    5  p1 =   41  p2 =    7  p3 =   31
  p0 =   41  p1 =   11  p2 =   13  p3 =   19
  p0 =   11  p1 =   23  p2 =   43  p3 =    7
  p0 =   23  p1 =   17  p2 =   31  p3 =   13
  p0 =   17  p1 =    5  p2 =   19  p3 =   43
==========
  p0 =    5  p1 =   31  p2 =   41  p3 =    7
  p0 =   31  p1 =   13  p2 =   23  p3 =   17
  p0 =   13  p1 =   11  p2 =   19  p3 =   41
  p0 =   11  p1 =   43  p2 =    7  p3 =   23
  p0 =   43  p1 =    5  p2 =   17  p3 =   19
==========
  p0 =    5  p1 =   31  p2 =    7  p3 =   41
  p0 =   31  p1 =   23  p2 =   13  p3 =   17
  p0 =   23  p1 =   11  p2 =   43  p3 =    7
  p0 =   11  p1 =   19  p2 =   41  p3 =   13
  p0 =   19  p1 =    5  p2 =   17  p3 =   43
==========
  p0 =    5  p1 =    7  p2 =   41  p3 =   31
  p0 =    7  p1 =   11  p2 =   23  p3 =   43
  p0 =   11  p1 =   13  p2 =   19  p3 =   41
  p0 =   13  p1 =   17  p2 =   31  p3 =   23
  p0 =   17  p1 =    5  p2 =   43  p3 =   19
==========
  p0 =    5  p1 =    7  p2 =   31  p3 =   41
  p0 =    7  p1 =   23  p2 =   11  p3 =   43
  p0 =   23  p1 =   13  p2 =   17  p3 =   31
  p0 =   13  p1 =   19  p2 =   41  p3 =   11
  p0 =   19  p1 =    5  p2 =   43  p3 =   17
[mike@europa Pentagon]$ 
//====================Specimin output===================================

Target:  84  n_primes:  24  n_nodes:  936  n_unique:   12
Primes> 5,7,31,41, 7,23,11,43, 23,13,17,31, 13,19,41,11, 19,5,43,17
Primes> 5,7,41,31 7,11,23,43, 11,13,19,41, 13,17,31,23, 17,5,43,19

//======================================================================
void rmdup(int *a, int *n);

void rmdup(int *a, int *n) {
	int i,j,k;
	// remove duplicate values from an integer array
	for(i=0;i<(*n);i++){
		for(j=i+1;j<(*n);) {
			if(a[j]==a[i]) {
				for(k=j;k<(*n);k++) a[k]=a[k+1];
				*(n)-=1;
			}
		else j++;
	   }
	}
}

https://github.com/voyager23/Pentagons.git


setupPrimeLinkedList.o : setupPrimeLinkedList.c $(DEPS)
	gcc -c $< $(CFLAGS) $(INC) $(LIB) -o $@

searchPenta.o : searchPenta.c $(DEPS)
	gcc -c $< $(CFLAGS) $(INC) $(LIB) -o $@
	
searchNodesLinkedList.o : searchNodesLinkedList.c $(DEPS)
	gcc -c $< $(CFLAGS) $(INC) $(LIB) -o $@

utilities.o : utilities.c $(DEPS)
	gcc -c $< $(CFLAGS) $(INC) $(LIB) -o $@
	
searchPentagonArray.o : searchPentagonArray.c $(DEPS)
	gcc -c $< $(CFLAGS) $(INC) $(LIB) -o $@	

searchPentagonLinkedList.o : searchPentagonLinkedList.c $(DEPS)
	gcc -c $< $(CFLAGS) $(INC) $(LIB) -o $@	

//======================================================================
	
#if()	
	time_t t1,t2;
	printf("Array search\n");
	time(&t1);
	n_pentagons = searchPentagonArray(&Nodes, &Pentagons, Target);
	time(&t2);
	printf("n_pentagons = %d in %.f seconds\n", n_pentagons,difftime(t2,t1));
	printf("Length of Pentagons list %d\n", g_slist_length(Pentagons));
#endif	

//======================================================================

int add_Pentagons_to_list(GSList**Pentagons, struct ring5 *working) {
	struct ring5 *new_rot, *new_ref;
	int i;
	if(find_Pentagon(Pentagons, working) == 0) {
		// rotations & reflections
		for(i=0;i<5;i++) {
			allocate struct ring5 -> new_rot
			allocate struct ring5 -> new_ref
			deep copy working -> new_rot
			deep copy working -> new_ref
			rotate(new_rot,i)
			rotate(new_ref,i)
			append(Pentagons,new_rot)
			append(Pentagons,new_ref)
		}
	}
}

int find_Pentagon(GSList **Pentagons, struct ring5 working) {
	// Pentagons are found by matching 5 pairs of primes p0 & p2
	GSList *target = *Pentagons;
	int i;
	while(target != NULL) {
		found = 1;
		for(i=0;i<5;i++) {
			if(	(working->nodes[i]->primes[0] != RPTR(target)->nodes[i]->primes[0])||
				(working->nodes[i]->primes[2] != RPTR(target)->nodes[i]->primes[2]))
				found=0;
				break;
			}
		if(found==1) return 1;
	}
	return 0;
}

